1. Negative Infinity: is a number in JavaScript which can be derived by dividing negative number by zero.
2. Breaking within a string statement can be done by the use of a backslash, '\', at the end of the first line
eg: document.write("This is \a program");
3. If the program tries to read the value of an undeclared variable, then a runtime error is encountered ie. 'not Defined'
while f the program tries to read the value of an undefined variable, an undefined value is returned.
4. The var keyword is used to declare a local variable or object. If the var keyword is omitted, a global variable is declared.
5. The setTimeout(function, delay) function is used to start a timer that calls a particular function after the mentioned delay.
6. === is called as strict equality operator which returns true when the two operands are having the same value without any type conversion.
7. Variable typing: is used to assign a number to a variable and the same variable can be assigned to a string.
eg:
 	i = 10;
	i = "string";
8. 3+2+5+''="10"
9. types of Pop up boxes : Alert, Confirm and Prompt
10. Void(0) is used to call another method without refreshing the page.
11. All variables in the JavaScript are object data types.
12. Escape characters (Backslash) is used when working with special characters like 
single quotes, double quotes, apostrophes and ampersands. Place backslash before the characters to make it display.
document.write "I m a "good" boy"    will be..
document.write "I m a \"good\" boy"
13. Cookies are the small test files stored in a computer and it gets created when the user visits the websites to store information that they need. 
14. The shift() method is similar as the pop() method but the difference is that the Shift method works at the start of the array.
15. Two basic groups of dataypes in JavaScript:
Primitive types are number and Boolean data types. Reference types are more complex types like strings and dates.
16. 'Typeof' is an operator which is used to return a string description of the type of a variable.
17. Try   {  Code   }
Catch(exp){ Code to throw an exception }
Finally   { Code runs either it finishes successfully or after catch }
18. Unshift method is like push method which works at the beginning of the array. 
This method is used to prepend one or more elements to the beginning of the array like push append.
19. A value can be appended to an array in the given manner - arr[arr.length] = value;
20. nonymous function:
A function that is declared without any named identifier is known as an anonymous function. In general, an anonymous function is inaccessible after its declaration.
var anon = function(){
	alert('I am anonymous');
}
anon()
21. Closure: is a locally declared variable related to a function which stays in memory when the function has returned.
22. call() vs apply()
call() is used when the number of the function's arguments are known to the programmer.
apply() is used when the number is not known. The function .apply() expects the argument to be an array.
23. Event bubbling: JavaScript allows DOM elements to be nested inside each other. In such a case, 
					if the handler of the child is clicked, the handler of parent will also work as if it were clicked too, like a bubble.
Note: via event capturing, we can only work on one event, either child or parent.
24. var myArray = [[[]]];             declares a three dimensional array.
25. EncodeURl() is used to convert URL into their hex coding. And DecodeURI() is used to convert the encoded URL back to normal.
26. ERRORS IN JS:
JavaScript gives a message if it encounters an error. The recognized errors are -
Load-time errors: The errors shown at the time of the page loading are counted under Load-time errors. These errors are encountered by the use of improper syntax, and thus are detected while the page is getting loaded.
Run-time errors: This is the error that comes up while the program is running. It is caused by illegal operations, for example, division of a number by zero, or trying to access a non-existent area of the memory.
Logic errors: It is caused by the use of syntactically correct code, which does not fulfill the required task. For example, an infinite loop.

_____________________________________________________________________________________________________________________________________________________________

1. In JS, global means 'not inside the function'
2. Hoisting: Setup memory space for variable and functions
Its not like that whatever var we declare, js takes it in start
eg
var a="hello world";
function b() {
    console.log("b is called")
}
b();
console.log(a);						//b is called
									  hello world

b();
console.log(a);
var a="hello world";
function b() {
    console.log("b is called")
}									//b is called
									  undefined
note: 'undefined' is the default placeholder for any var
eg:
a. var a;
   console.log(a);					// undefined
b. console.log(a);					// Uncaught ReferenceError: a is not defined

3. JS is a single threaded, synchronus execution language
Single threaded: One command at a time
Synchronus Execution: One at a time

4. 
static typing:
int a = 'Naman'		//error

dynamic typing:
var a = 1
a = 'nikhil'


5. Primitive type: is a type that holds only a single value but not an object
undefined vs null:
both shows lack of existence but you should assign null to variables, not undefined
 Symbol: its a datatype used in ES6, not in course

6. Operators: A special function thats is written differently
generally takes 2 parameters and gives one result

7. Operator Precedence: which operator calls first
Operator Associativity: Whats the order of execution (LtoR or RtoL)
Associativity comes when operators have same precedence
To check Precedence:  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

8. COERCION: converting a value from one type to another
eg: var a = 1 + '2'
o/p: 12

9. Equality(==) & Strict Equality(===):
Number(null)			// 0
Number(undefined)		// NaN
Number(false)			// 0
Number(true)			// 1

false == 0				//true
false === 0				//false

null == 0				// false
null === 0				// false

NOTE: Somewhere (==) also works well. so to avoid confusion we use (===)

10. 
var a
if(a) { console.log("Something") }				//

a=1
if(a) { console.log("Something") }				// Something

a=0
if(a) { console.log("Something") }				//

11. 
function greet(){ console.log('hello', name); }
greet()					// hello undefined

12. or(||) always searches the true value:
undefined || "hello"			// "hello"
1 || 0							// 1
3 || 0							// 3
undefined || 2					// 2

13. Classical and Prototypal Inheritance:
Classical is verbose: using or expressed in more words than are needed.
Prototypal is simple and extensible

14. PROTOTYPE:
All objects have some property. One property is Prototype
This prototype property is simply a ref to another object, called as proto{}
One object can have a prototype and that proto{} can refer to another proto{}
Obj->prop1, Obj->proto->prop2, Obj->proto->proto->prop3
Now Obj can access prop1, prop2 or prop2 like Obj.prop3 directly
This is called Prototype Chain.
Another Obj2 can also access these prop directly.
eg:
var person = {
    firstname: 'Default',
    lastname: 'Default',
    getFullName: function() {
        return this.firstname + ' ' + this.lastname;  
    }
}

var john = {
    firstname: 'John',
    lastname: 'Doe'
}

// don't do this EVER! for demo purposes only!!!
john.__proto__ = person;
console.log(john.getFullName());			// John Doe
console.log(john.firstname);				// John

var jane = {
    firstname: 'Jane'   
}

jane.__proto__ = person;
console.log(jane.getFullName());			// Jane Default

person.getFormalFullName = function() {
    return this.lastname + ', ' + this.firstname;   
}

console.log(john.getFormalFullName());		// Doe, John
console.log(jane.getFormalFullName());		// Default, Jane
NOTE: object first give priority to local var

15. Everything is an object in js
var a = {};
var b = function() {};
var c = [];
a.__proto__ 						// object
a.__proto__.__proto__				// object
b.__proto__ 						// function
b.__proto__.__proto__				// object

16. REFLECTION: An obj can look at itself, change its property and methods
var person = {
    firstname: 'Default',
    lastname: 'Default',
    getFullName: function() {
        return this.firstname + ' ' + this.lastname;  
    }
}

var john = {
    firstname: 'John',
    lastname: 'Doe'
}

// don't do this EVER! for demo purposes only!!!
john.__proto__ = person;

for (var prop in john) {
    console.log(prop + ': ' + john[prop]);
}
o/p:
firstname: John
lastname: Doe
getFullName: function() {
        return this.firstname + ' ' + this.lastname;  
    }


for (var prop in john) {
    if (john.hasOwnProperty(prop)) {
        console.log(prop + ': ' + john[prop]);
    }
}
o/p:
firstname: John
lastname: Doe


17. EXTEND:
var john = {
    firstname: 'John',
    lastname: 'Doe'
}

var jane = {
    address: '111 Main St.',
    getFormalFullName: function() {
        return this.lastname + ', ' + this.firstname;   
    }
}

var jim = {
    getFirstName: function() {
        return firstname;   
    }
}

_.extend(john, jane, jim);              // extends john with jane and jim

console.log(john);
o/p:
Object
firstname: "John"
lastname: "Doe"
address: "111 Main St."
getFormalFullName: ƒ ()
getFirstName: ƒ ()


18. Member Access(.) & Computed Member Access([]) operators for object
var ob= new Object();
ob.first="nikhil"
ob.last="singhal"
console.log(ob.first)						// nikhil
ob.address=new Object();
console.log(ob.address)						// {}
ob.address.street="101 barakhamba road"
console.log(ob.address.street)				// 101 barakhamba road

NOTe:
Above object can also be defined as:
var ob = {
	first : "nikhil",
	last : "singhal",
	address : {
		street: "101 barakhamba road"
	}
};

19. NAMESPACE: A conatiner for variables and function
var a="hello"
var a="hola"
console.log(a)						// hola
var english={}
english.a="hello"
var spanish={}
spanish.a="hola"
console.log(english.a)				// hello
console.log(english.greetings.a)	// Uncaught TypeError: Cannot read property 'a' of undefined
NOTE: (.) operator is left associative so cant find greetings first

20. stringify and parse:
var a = {x:1, y:2}
JSON.stringify(a)							// "{"x":1,"y":2}"
JSON.parse("{"x":1,"y":2}")
var b= JSON.parse('{"x":1,"y":2}')
b 											// {x: 1, y: 2}

21. Functions are objects in js:
function greet(){ console.log('hello')}
greet()							// hello
greet.a="this is a"
console.log(greet)				// ƒ greet(){ console.log('hello')}
console.log(greet.a)			// this is a

22. If line starts with the word 'function()', it initiates it at the same time:
function a() { console.log('hello') }
a()														// hello
NOTE: a() can be written above the func defination as well

As func is a variable and its also anonymous func:
var b = function() { console.log("hello b")}
b 														// ƒ () { console.log("hello b")}
b()														// hello b
c()														// Uncaught ReferenceError: c is not defined

23. function can be passed and called inside another func as well:
function log(){
    console.log('hello')
}

function logs(a){
    console.log(a)
}

logs('hi')
														// hi
logs(function log(){
    console.log('hello')
})														// ƒ log(){ console.log('hello') }

function logs(a){ a() }

logs(function log(){ console.log('hello') })			// hello


24. Primtive type var uses 'call by value' while object uses 'call by reference':
a=2
b=a
a=3
console.log(a, b)							// 3 2
x={a:1}
y=x
x.a=2
2
console.log(x, y)							// {a: 2} {a: 2}

NOte: if uses (=) operator, then it holds the new value and sets up a new memory space
x={a:4}
console.log(x, y)							// {a: 4} {a: 2}

25. THIS:
initially this point to global object ie. window
when you create a function and log this inside it, it still point to 'window'
function a() { console.log(this); this.x="hello"; }
a()							// Window {parent: Window, opener: null, top: Window, length: 0, frames: Window, …}
console.log(x)				// hello
NOTE: now x will be a variable on global window

26. ARRAY: its a collection of anything:
arr=[1, true, {name:"nikhil"}, function(name){ console.log(name) }, "naman"]
arr 										// (5) [1, true, {…}, ƒ, "naman"]
arr[3](arr[2].name)							// nikhil

27. arguments and spread:
function greet(f,l, ...other){
	console.log(f);
	console.log(l);
	console.log(arguments);
	console.log(other);
}
greet("nikhil","singhal", "wahtever we want", "will come here")

o/p:
nikhil
singhal
Arguments(4) ["nikhil", "singhal", "wahtever we want", "will come here", callee: (...), Symbol(Symbol.iterator): ƒ]
(2) ["wahtever we want", "will come here"]

28. Default parameters and use of Arguments:
function greet(f,l, ...other){
	if(arguments.length === 0){
		console.log("No parameters passed")
	} else {
		f=f || "FIRST";
		l=l || "LAST";
	console.log(f);
	console.log(l);
	console.log(arguments);
	console.log("_________________________")
}
}
greet("nikhil","singhal", "wahtever we want", "will come here")
greet();
greet("naman")

o/p:
nikhil
singhal
Arguments(4) ["nikhil", "singhal", "wahtever we want", "will come here", callee: (...), Symbol(Symbol.iterator): ƒ]
 _________________________
No parameters passed
naman
LAST
Arguments ["naman", callee: (...), Symbol(Symbol.iterator): ƒ]
 _________________________

 29. FUNCTION OVERLOADING:
 Normally we dont have this feature in js:
 function greet(f,l,lang){
	lang=lang || "en";
	if(lang === "en"){
		console.log("hello "+f+" "+l);
	}

	if(lang === "sp"){
		console.log("hola "+f+" "+l);
	}
}
greet("nikhil","singhal","en");
greet("nikhil","singhal","sp");

o/p:
app.js:4 hello nikhil singhal
app.js:8 hola nikhil singhal

BUT CAN CREATE A CUSTOM ONE BY YOURSELF:
function greet(f,l,lang){
	lang=lang || "en";
	if(lang === "en"){
		console.log("hello ",f," ",l);
	}

	if(lang === "sp"){
		console.log("hola ",f," ",l);
	}
}

function greetEnglish(first,last) {
	greet(first, last, "en");
}

function greetSpanish(first,last) {
	greet(first, last, "sp");
}

greetEnglish("nikhil", "singhal");
greetSpanish("nikhil", "singhal");

30. js automatic insert semicolon sometimes, so better insert by yourself where needed
function greet() {
	return 
	{
		first: "Nikhil"
	}
}
console.log(greet()); 			// undefined

So use {} at right place
function greet() {
	return {
		first: "Nikhil"
	}
}
console.log(greet()); 			// {first: "Nikhil"}

31. IIFE (Immediately Invoked Function Expression):
//USING A FUNC STATEMENT
function greet(name) {
	console.log("hello", name);
}
greet("John");

//USING A FUNC EXPRESSION (Also called First class functions)
var a = function(name) {
	console.log("hello", name);
}
a("cena");

//USING IIFE
var a = function(name) {
	console.log("hello", name);
}('Batista');
a;							// It'll also work if won't write a

//USING IIFE2
(function(name) {
	console.log("hello", name);
}('Undertaker'));

o/p:
hello John
app.js:9 hello cena
app.js:15 hello Batista
app.js:21 hello Undertaker


32. Suppose we have 2 js files in out HTML code:
 		<script src="greet.js"></script>
        <script src="app.js"></script>

 greet.js:
 a="hola";

 app.js:
 console.log("Outer:", a)
function greet(){
	a="hello";
	console.log("Inner:", a);
}
greet()
o/p:
Outer: hola
Inner: hello


function greet(){
	a="hello";
	console.log("Inner:", a);
}
greet()
console.log("Outer:", a)
Inner: hello
Outer: hello


33. Closures: if a function needs any var which is defined outside that func, 
its usable wheather func outside which declared that var is there or done
eg:
function greet(first) {
	return function(last){
		console.log(first," ",last)
	}
}
greet("nikhil")("singhal")
Note: Here when we call the anonymous func inside greet, greet is over and also first, but 'first' is accesible inside as well.

34. Function Overloading can be possible using closures as well:
function makeGreetings(lang){							// makeGreeting is a factory function here
	return function(f,l){
		if(lang === "en"){
		console.log("hello ",f," ",l);
	}
	if(lang === "sp"){
		console.log("hola ",f," ",l);
	}
   }
}

var greetEnglish = makeGreetings("en");
var greetSpanish = makeGreetings("sp");
greetEnglish('Ram', 'Kumar');
greetSpanish('Ram', 'Kumar');
NOTE: when greetEnglish() will be called, it'll have 2 langs, lang="en" and lang="sp", 
and using the closure property of js, func will attach lang="en" 

35. SETTIMEOUT is also a CLOSURE:
function itsClosure(){
	var a = "nikhil";
	setTimeout(function(){
		console.log(a);
	}, 3000);
}
itsClosure();
Note: here setTimeout will print 'a' which was the part of itsClosure() but accessible inside setTimeout using closure.

36. CALLBACK FUNCTION:
A funtion you give to another funcm to be run when the other func is finished
So the func you call, 'calls back' by calling the function you gave it when it finishes.
function itsCallbackFunc(callback) {
	a=1000;
	callback();
}

itsCallbackFunc(function(){
	console.log("I am done", a);
})

itsCallbackFunc(function(){
	console.log("All done");
})

o/p:
I am done 1000
All done


37. BIND(): Creates an exact copy.
var person= {
	f:'john',
	l:'Doe',
	getName: function(){
		return this.f + ' ' + this.l;
	}
}

var log= function(lang1, lang2){
	console.log(this.getName());
}

var logByBindFunc= log.bind(person);
logByBindFunc();
NOTE: here we use this as f and l will point to person.


38. CALL() AND APPLY(): () just creates a copy but here you can modify the calling by yourself.
var person= {
	f:'john',
	l:'Doe',
	getName: function(){
		return this.f + ' ' + this.l;
	}
}

var log= function(lang1, lang2){
	console.log("languages:", lang1, " ", lang2);
	console.log(this.getName());
	console.log("______________________")
}

var logByBindFunc= log.bind(person);
logByBindFunc('en', 'sp');
log.call(person, 'xx', 'yy');
log.apply(person, ['xx', 'yy']);

O/P:
languages: en   sp
john Doe
______________________
languages: xx   yy
john Doe
______________________
languages: xx   yy
john Doe

NOTE: apply needs array[] to pass parameters

ANOTHER EXAMPLE:
var john = {
    name: 'John',
    presentation: function(style, timeOfDay) {
        if (style === 'formal') {
            console.log(timeOfDay + ' I am ' +  this.name);
        } else if (style === 'friendly') {
            console.log('Hey! I am ' +  this.name + ' '+ timeOfDay);
        }
    }
};

var emily = {
    name: 'Emily',
    age: 35,
    job: 'designer'
};

john.presentation('formal', 'morning');
// morning I am John

john.presentation.call(emily, 'friendly', 'afternoon');
// Hey! I am Emily afternoon

john.presentation.apply(emily, ['friendly', 'afternoon']);
// Hey! I am Emily afternoon

var johnFriendly = john.presentation.bind(john, 'friendly');

johnFriendly('morning');
// Hey! I am John morning

johnFriendly('night');
// Hey! I am John morning night

var emilyFormal = john.presentation.bind(emily, 'formal');
emilyFormal('afternoon');
// afternoon I am Emily


39. FUNC BORROWING:
var person= {
	f:'john',
	l:'Doe',
	getName: function(){
		return this.f + ' ' + this.l;
	}
}

var person2= {
	f:'Ram',
	l:'Kumar'
}
console.log(person.getName.apply(person2));
O/P:
Ram Kumar

40. FUNC CURRYING:
function multi(a,b){
	return a*b;
}
var multiByTwo = multi.bind(this, 2);
console.log(multiByTwo(3));					// 6
NOTE:
var multiByTwo = multi.bind(this, 2);
is working like:
function multiByTwo(b){
	a=2;
	return a*b;
}
2 is passed in function as a first parameter. we can also pass both para there.
if we pass both para by bind, it won't consider the outer paras:
function multi(a,b){
	return a*b;
}
var multiByTwo = multi.bind(this, 2, 4);
console.log(multiByTwo(3));					// 8


41. Normally to make second array double of first one:
var arr1=[1,2,3];
console.log(arr1);

var arr2=[];
for(i=0; i<arr1.length; i++){
	arr2.push(arr1[i]*2);
}
console.log(arr2);

o/p:
[1, 2, 3]
[2, 4, 6]

NOW: BY FUNCTIONAL PROGRAMMING:
function mapForEach(arr, fn){
	var newArr=[];
	for(var i=0; i< arr.length; i++){
		newArr.push(
			fn(arr[i])
			)
	};
	return newArr;
}

var arr1=[1,2,3];
console.log(arr1);

// var arr2=[];
// for(i=0; i<arr1.length; i++){
// 	arr2.push(arr1[i]*2);
// }

var arr2= mapForEach(arr1, function(item){
	return item*2;
})
console.log(arr2);
o/p:
[1, 2, 3]
[2, 4, 6]


Now the same func 'mapForEach' can be used :
var arr3= mapForEach(arr1, function(item){
	return item>2;
})
console.log(arr3);
[false, false, true]


// MORE EX. OF FUNCTIONAL PROGRAMMING:
var checkPastLimit =  function(limiter, item) {
	return item > limiter;
}
var arr4 = mapForEach(arr1, checkPastLimit.bind(this,1));
console.log(arr4);
o/p:  
[false, true, true]

// NOW IF YOU WANNA REMOVE ADDING BIND ALL THE TIME:
var checkPastLimitSimplified = function(limiter) {
	return function(limiter, item) {
		return item > limiter;
	}.bind(this, limiter);
};
var arr5 = mapForEach(arr1, checkPastLimitSimplified(1));
console.log(arr5);


42. underscore.js is the library having ready to use func
Ref: underscorejs.org -> downloads(Development Version)
To study more: underscorejs.org -> Annotated Source
Just download unserscore.js and save it in the same folder.
var arr6 = _.map(arr1, function(item) { return item * 3});
console.log(arr6);																	// [3, 6, 9]

var arr7 = _.filter([1,2,3,4,5,6], function(item) { return item % 2 === 0 });
console.log(arr7);																	// [2, 4, 6]
NOTE: lodash.com is also good for study.

_______________________________________________________________________________________________

43. If we craete a func, then create the object of that func.
Then if that func doesn't return any value, then it returns the value at 'this':
function Person(f,l){
	console.log(this);
	this.f="Nikhil";
	this.l="Singhal";
}

var x = new Person();
console.log(x);
O/P:
Person {}
Person {f: "Nikhil", l: "Singhal"} 


44. If return , it shows that:
function Person(f,l){
	console.log(this);
	this.f="Nikhil";
	this.l="Singhal";
	return {greeting: 'Hello'};
}

var x = new Person();
console.log(x);
O/P:
Person {}
{greeting: "Hello"}

45.PROTOTYPE: Its not of the function but the object created of that function.
means the object of that func can use that prototype but not the func
By creating a single prototype func, we can use it for any object.
eg:
function Person(f,l){
	console.log(this);
	this.f=f;
	this.l=l;
	console.log("The Func is invoked");
}

var x = new Person("nikhil", "Singhal");				// Function Constructors
console.log(x);

Person.prototype.getFullName= function(){
	return this.f+' '+this.l;
}

console.log(x.getFullName());
O/P:
The Func is invoked
Person {f: "nikhil", l: "Singhal"}
nikhil Singhal

46. if mistakenly we dont use 'new', and write:
var x = Person("nikhil", "Singhal");
o/p:
Window {parent: Window, opener: null, top: Window, length: 0, frames: Window, …}
The Func is invoked
undefined
Uncaught TypeError: Cannot read property 'getFullName' of undefined

So better make the first letter capital of the function constructors so that the VS code can give error if dont use 'new'.

47. BUILT IN FUNC CONSTRUCTORS:
var str = new String("NIkhil");
str
O/P: String {"NIkhil"}
NOW 'str.' will give the same function access like we get by 'String.prototype.' (on console).
eg:
var i = new Number(3)
i
o/p: Number {3}

48. We can create our own functions using prototype that we can use later on any string.
String.prototype.getLimit= function(limit) {
	return this.length > limit;
}
var a = new String("John");
console.log(a.getLimit(3));
O/P: true

49. Number and Object are different though they work same:
var a=2;
var b = new Number(2);
typeof(a)								// "number"
typeof(b)								// "object"
a==b 									// true
a===b 									// false
Ref: momentjs.com

50. All arrays are object in js:
Array.prototype.fullName='Ram';
var arr = ['a','b','c'];
for(var i in arr){
	console.log(i+':',arr[i])
}
O/P:
0: a
1: b
2: c
fullName: Ram


51. Function constructor tries to mimic other programming lag while 'Object.create' is another way in js to create object
var person = {
	f:"Nikhil",
	l:"Singhal",
	greet: function(){
		return "hi "+ this.f;
	}
}

var john = Object.create(person);
console.log(john);
O/P:
{}
But if you'll open its prototype, you'll see person there

var john = Object.create(null);
console.log(john);								// {} only
POLYFILL: Code that adds a feature which the engine may lack.

52.Class is an object in js:
then you create new object from that object(class)
class is better than function constructor in a way that 
here due to class, people use 'new' keyword while creating obj which they dont rem in case of func cons
'extends' keyword is use to set the prototype in class

Syntactic Sugar:
A different way to type something that doesn't change how it works under the hood

__________________________________________________________________________________________________________________________________

53. typeof and instanceof:
var a = 3;
console.log(typeof a);				// number

var b = "Hello";
console.log(typeof b);				// string

var c = {};
console.log(typeof c);				// object

var d = [];
console.log(typeof d); // weird!							//object
console.log(Object.prototype.toString.call(d)); 			// [object Array]

function Person(name) {
    this.name = name;
}

var e = new Person('Jane');
console.log(typeof e);										// object
console.log(e instanceof Person);							// true

console.log(typeof undefined); 								// undefined
console.log(typeof null);   								// object 		// a bug since, like, forever...

var z = function() { };
console.log(typeof z);										// function

54. USE STRICT:
var person;
person2 = {};
console.log(person2);
o/p:
{}

Now if I use "use strict"
o/p:
Uncaught ReferenceError: person2 is not defined
Ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode

________________________________________________________________________________________________________________________________

55. TRANSPILE:
Convert the syntax of one programming lang into another.
For more on Typescript head to: http://www.typescriptlang.org
and try out writing Typescript code in your browser here: http://www.typescriptlang.org/Playground
For more on Traceur head to: https://github.com/google/traceur-compiler
and try out writing ES6 code in Traceur in your browser here: https://google.github.io/traceur-compiler/demo/repl.html#

56. 
console.clear();
var z = 10;

if (isNaN(z) && (typeof z === "number")) {					// if (window.isNaN(z)) {				// if (Number.isNaN(z)) {
  console.log('It is exactly NaN');
} else {
  console.log('It is not a number, it is something else, it could be string, boolean');
}
O/p:
"It is not a number, it is something else, it could be string, boolean"


57. var z = new Date('02-30-2019');
console.log(z);
o/p:
Sat Mar 02 2019 00:00:00 GMT+0530 (India Standard Time)

58. Check 2 dates are equal or not, also sort them
console.clear();
var a= new Date('02-28-2019');
var b= new Date('02-26-2019');
var c= new Date('02-27-2019');

console.log(a.getTime()==b.getTime());			// false
console.log(a.getTime()==c.getTime());			// false

var d = [a,b,c];
d.sort((a,b)=>{return a-b;})
console.log(d)
//[Tue Feb 26 2019 00:00:00 GMT+0530 , Wed Feb 27 2019 00:00:00 GMT+0530 , Thu Feb 28 2019 00:00:00 GMT+0530]

59. prototype vs __proto__
prototype is used by constructor() functions. It should've really been called something like, "prototypeToInstall", since that's what it is.
and __proto__ is that "installed prototype" on an object (that was created/installed upon the object from said constructor() function)

60. 
 function a (name) {
  this.name = name;
 }
undefined
a
ƒ a (name) {
  this.name = name;
 }
a.prototype
{constructor: ƒ}constructor: ƒ a(name)length: 1name: "a"arguments: nullcaller: nullprototype: {constructor: ƒ}__proto__: ƒ ()[[FunctionLocation]]: VM103:1[[Scopes]]: Scopes[1]__proto__: Object
var b = new a ('JavaScript');
undefined
b.__proto__
{constructor: ƒ}

NOW: b.__proto__ === a.prototype

_________________________________________________________________________________________________________________________________________________________

COMPLETE FUNDAMENTALS:
1. 
inline js:
 	<script>
    	console.log("hello World");
    </script>

external js:
 	<script src="script.js">
    </script>

2. Type Coercion: converting one datatype to another
   Variable mutation: changing the type of var by assigning diff type of data into it.

3. falsy values: undefined, null, 0, '', NaN
var a
if(a){console.log('a is defined')} else{ console.log('a is not defined')}
a is not defined
a=''
if(a){console.log('a is defined')} else{ console.log('a is not defined')}
a is not defined
a=2
if(a){console.log('a is defined')} else{ console.log('a is not defined')}
a is defined

4.  Function declaration
function whatDoYouDo(job, firstName) {}

	Function expression
var whatDoYouDo = function(job, firstName) {}

Function expression produces immediate results while declarations dont

5. Array: if value is not present in the array, the index is -1
a=[1,2,3,4]
a.indexOf(2)			// 1
a.indexOf(5)			// -1

6. Execution Context: A box or a container which stores variables and in which a piece of our code is evaluated and executed
Global Execution Context: 
a. Code thts not inside any func
b. Associated with the global obj
c. in browser, its window obj ie a === window.a

7. HOISTING:
For func, hoisting only works for functions declarations, not for func expressions
calculateAge(1965);					// WORKS

function calculateAge(year) {
    console.log(2016 - year);
}

retirement(1956);					// ERROR
var retirement = function(year) {
    console.log(65 - (2016 - year));
}

8. THIS:
when a default a func call happens, then the default obj is window obj
console.log(this);							// window						

calculateAge(1985);							

function calculateAge(year) {
    console.log(2016 - year);				// 31
    console.log(this);						// Window
}

var john = {
    name: 'John',
    yearOfBirth: 1990,
    calculateAge: function() {
        console.log(this);							// {name: "John", yearOfBirth: 1990, calculateAge: ƒ}
        console.log(2016 - this.yearOfBirth);		// 26
        
        function innerFunction() {
            console.log(this);						// Window
        }
        innerFunction();
    }
}

john.calculateAge();


FUNC BORROWING:
var mike = {
    name: 'Mike',
    yearOfBirth: 1984
};


mike.calculateAge = john.calculateAge;
mike.calculateAge();							// 32
												// Window


9. DOM: Document Object Model
Structured representation on an HTML docs
The dom is used to connect webpages to scripts like JS.
For each HTML box, there is an obj in the DOM that we can access and interact with.
The object that gives us access to the DOM is the 'document' object 

10. innerHTML vs textContent:
innerHTML can execute the styling as well
document.querySelector('#current-0').innerHTML='<em>' + dice + '</em>';				//	works
document.querySelector('#current-0').textContent='<em>' + dice + '</em>';			// not work and shows tags instead

11. To hide a dom object:
document.querySelector('.dice').style.display='none';

12. PROTOTYPE: 
js is a prototype base lang means inheritance works here by using prototype
every js obj has prototype property
if we creatan object's blueprint like Person{name, class, address} then
person's prototype is not for person but the instance of person which will use it like John
Other words: Person's prototype property is the prototype for John
Even Person(or any other) object that we create, is an instance of the OBJECT CONSTRUCTOR that has predefined funcs in its prototype property 
When a certain method or property is called, the search starts in the object itself and is not found, goes to the object's prototype and so on.
So this is the prototype chain and null is the final link in this chain that has no prototype
In prototype property of an object, we have those property and methods that we want to inherit
eg:
var person =  function(name, age){
    this.name = name;
    this.age = age;
    this.calculateAge = function(){
        console.log(50 - this.age);
    }
}
var john = new person('jane', '12');
john.calculateAge();					//38

Using prototype property, we can use it like:
var person =  function(name, age){
    this.name = name;
    this.age = age;
}

person.prototype.calculateAge = function(){
        console.log(50 - this.age);
    }

var john = new person('jane', '12');
john.calculateAge();
NOTE1: here 'person.prototype' and after expanding john's __proto__ property, you will get the same things( like calculateAge() and lastname)
i.e john.__proto__ === person.prototype
NOTE2: person.prototype.lastname='Smith'
THEN:
john.hasOwnProperty('name')					// true
john.hasOwnProperty('lastname')				// false
john instanceof Person 						// true


13. Object.create vs func constructor:
Object.create builts an obj that inherits directly from the one that we passed into the 1st argument
while func cons inherits from the object's prototype property
Object.create is better the func cons as it allows us to directly specify that which object should have cons and
also help to work in complex inheritance structure
var person={
calculateAge: function() {
    console.log(50 - this.age);			
}
}

var john = Object.create(person);
console.log(john);						// {}

var jane = Object.create(person, {
    name: { value: 'Jane'},
    age: { value : 20}
})

console.log(jane);						// {name: "Jane", age: 20}				
console.log(jane.calculateAge())		// 30


14. PRIMITIVE VS OBJECT:
PRIMITIVE:
Each var holds its own copy of the own data and doesnot refer anything
var a=23;
var b =a;
a =46;
console.log(a);				// 46
console.log(b);				// 23

OBJECT:
Refer and change:
var obj1 = {
    name: 'john',
    age: 20
}

var obj2 = obj1;
obj1.age=22;
console.log(obj1.age);			// 22
console.log(obj2.age);			// 22

NOTE:
If we pass a primitive and an object's property inside a func and change, 
then primitive doesn't change but object's prop does due to reference.


15. First class Functions:
A func is an instance of the Object type so a func behaves like any other obj
 Passing func as arguments:
 a1=[10,20,30,40,50];

function arrayCalc(arr,fn){
var a2 = [];
    for(var i=0; i<arr.length; i++) {
        a2.push(fn(arr[i]));
    }
    return a2;
}

function findAge(el) {
    return 100-el;
}

var ages = arrayCalc(a1, findAge);
console.log(ages);
O/P: [90, 80, 70, 60, 50]


16. Functions returning func:
function jobType(job) {
    if(job === 'teacher') {
        return function(name) {
            console.log('teacher: '+name)
        }
    } else if(job === 'lawyer') {
        return function(name) {
            console.log('lawyer: '+name)
        }
    } else {
        return function(name) {
            console.log('Mention your profession: '+name)
        }
    }
}
var state = jobType('teacher');
console.log(state('Ram'))				// teacher: Ram

var state = jobType('doctor')('Ram');
console.log(state)						// Mention your profession: Ram


17. CLOSURES:
An inner func has always access to the variables and parameters of its outer func, 
even after the outer func has returned
eg:
function outerFunc(a) {
    var b = "outer var";
    return function innerFunc(c) {
        console.log(a,b,c)
    }
}

var x = outerFunc(10);
console.log(x(20));
O/P: 10 "outer var" 20
NOTE: a, b are accessible in innerFunc() even after outerFunc() has returned bcoz a,b are accessible for innerFunc due to closure


____________________________________________________________________________

ES6:
1. var(ES5) has a function scope while let,const(ES6) has block scope:
function es5Func(check){
    if(check){
        var first = "John";
        var last = "Miller";
    }
    console.log(first, last)
}

es5Func(true);						// John Miller

function es6Func(check){
    if(check){
        let first = "John";
        const last = "Miller";
    }
    console.log(first, last)
}

es6Func(true);						// Uncaught ReferenceError: first is not defined
 NOte:
 It can work in this way if we declare let and const outside if:
 function es6Func(check){
    let first;
    const last = "Miller";
    if(check){
        first = "John";
    }
    console.log(first, last)
}

es6Func(true);						// John Miller


2. we need to initialize const at the time of declaration:
let a;
a = "ram";
console.log(a)					// ram

const a;
a = "ram";
console.log(a)					// Uncaught SyntaxError: Missing initializer in const declaration


3. let has a block scope:
eg 1:
let i=23;
for(let i=0; i<=3; i++) {
    console.log(i);						// 0 1 2 3
}
console.log(i);							// 23

eg 2:
{
    let a = 5;
    const b=6;
}
console.log(a+b);				// Uncaught ReferenceError: a is not defined

while var is accessible:
// ES5
{
    var a = 5;
}
console.log(a);							// 5

but not using IIFE:
(function(){
    var c=3;
})();
console.log(c)							// Uncaught ReferenceError: c is not defined


4. Use of backticks makes string use easy:
let f = "Nikhil";
const l = "Singhal";
console.log('My name is:' + f + ' ' + l);           // ES5
console.log(`My name is ${f} ${l}`);                // ES6

const name = `${f} ${l}`;
console.log(name.startsWith('N'));					// true	
console.log(name.endsWith('N'));					// false
console.log(name.includes('kh'));					// true
console.log(name.repeat(3));						// Nikhil SinghalNikhil SinghalNikhil Singhal
IF WANT SPACE, THEN USE BACKTICKS:
console.log(`${name} `.repeat(3));					// Nikhil Singhal Nikhil Singhal Nikhil Singhal


5. using (=>):
//ES5
const years = [1990, 2010, 2005];
var ages5 = years.map(function(el) { 
return 2020 - el 
})
console.log(ages5)                              // [30, 10, 15]

//ES6
var ages6 = years.map(el => 2020 - el )
console.log(ages6)                              // [30, 10, 15]

ages6 = years.map((el, index) => `element at pos: ${index+1} is ${2020 - el}` )
console.log(ages6)                              // ["element at pos: 1 is 30", "element at pos: 2 is 10", "element at pos: 3 is 15"]
NOTE: now   [ function(el) { return  ] 		is replaces with   [  el =>   ]


6. Arrow func dont have their own 'this' keyword like the normal func,
In normal func call, this keyword always points to to global object(window) and
if its a method call, this keyword will point to the object 
So they share the surrouding this keyword means they use the this keyword of the function they are written in
and its call lexical 'this' keyword
eg1:
var box = {
    color: 'green',
    position: 1,
    clickme: function() {
        document.querySelector('.green').addEventListener('click', function() {
            var str = 'box color is: ' + this.color + ' and position is: ' + this.position;
            alert(str);
        });
    }
}
box.clickme();					
o/p: (in alert box): box color is: undefined and position is: undefined

Now replace inner function() with ()=>
'click', ()=> {

If we do it for outer as well then again it goes undefined as then this will refer the global window
NOTE: a little hack is that we can use function() inner as well, just write a new varible and assign this into it:
self = this and then call the using self like..
     var str = 'box color is: ' + self.color + ' and position is: ' + self.position;


eg2:
if function() format dont find this,then we use bind() to create a copy of this, to use it inside function():
// ES5
function Person(name) {
    this.name = name;
}

Person.prototype.myfriends = 
    function(friends) {
    var arr =  friends.map(function(el) 
    {
        return this.name + ' is friends with ' + el;
    }.bind(this))
    console.log(arr);
}

var friendsList = ['Rahul', 'Sita'];
new Person('John').myfriends(friendsList);			// ["John is friends with Rahul", "John is friends with Sita"]


// ES
Person.prototype.myfriends6 = 
    function(friends) {
    var arr =  friends.map(el => `${this.name} is friends with ${el}` );
    console.log(arr);
}

new Person('John').myfriends6(friendsList);			// ["John is friends with Rahul", "John is friends with Sita"]

NOTE: call() is used for an instant func call


7. Destructuring:
const [name, age] = ['Nikhil', 26];
console.log(name);				// Nikhil
console.log(age);				// 26

const obj = {
    first : 'Nikhil',
    last : 'Singhal'
}

const {first, last} = obj;
console.log(first);				// Nikhil
console.log(last);				// Singhal

const {first: a, last: b} = obj;
console.log(a);					// Nikhil
console.log(b);					// Singhal


8. Array in ES5 and ES6:
.html:
<body>
 <div class="box green">I'm green!</div>
 <div class="box blue">I'm blue!</div>
 <div class="box orange">I'm orange!</div>
</body>


eg 1: To change the color of 3 boxes in one time:
const boxes  = document.querySelectorAll('.box');
console.log(boxes);

//ES5
const boxesArr5 = Array.prototype.slice.call(boxes);
boxesArr5.forEach(function(cur) {
    cur.style.backgroundColor= 'yellow';
});

//ES6
const boxesArr6 = Array.from(boxes);
boxesArr6.forEach(cur =>  cur.style.backgroundColor= 'yellow');

eg 2: To write 'I changed to blue', otherwise continue:
//ES5
for(var i = 0; i < boxesArr5.length; i++) {
    if(boxesArr5[i].className === 'box blue') {
        continue;
    }
    
    boxesArr5[i].textContent = 'I changed to blue!';  
}

//ES6
for (const cur of boxesArr6) {
    if (cur.className.includes('blue')) {
        continue;
    }
    cur.textContent = 'I changed to blue!';
}


eg 3: return the age which is greater than 18:
//ES5
var ages = [12, 17, 8, 21, 14, 11];
var full = ages.map(function(cur) {
    return cur >= 18;
});
console.log(full);										// [false, false, false, true, false, false]	
console.log(full.indexOf(true));						// 3
console.log(ages[full.indexOf(true)]);					// 21

//ES6
console.log(ages.findIndex(cur => cur >= 18));			// 3
console.log(ages.find(cur => cur >= 18));				// 21


9. Spread operator
function addFourAges (a, b, c, d) {
    return a + b + c + d;
}

var sum1 = addFourAges(18, 30, 12, 21);
console.log(sum1);									// 81

//ES5
var ages = [18, 30, 12, 21];
var sum2 = addFourAges.apply(null, ages);
console.log(sum2);									// 81

//ES6
const sum3 = addFourAges(...ages);
console.log(sum3);									// 81

const familySmith = ['John', 'Jane', 'Mark'];
const familyMiller = ['Mary', 'Bob', 'Ann'];
const bigFamily = [...familySmith, 'Lily', ...familyMiller];
console.log(bigFamily);								// ["John", "Jane", "Mark", "Lily", "Mary", "Bob", "Ann"]


10. Rest Parameters: they also use (...) but exact opposite to spread operator
Spread operator takes an array and transform it into single values
But rest para takes single values n transform it into array when we call a func with multiple para.

if we dont write paramters in func, by default it passes in 'arguments' which looks like an array but not exactly:

// ES5
function findAge() {
    console.log(arguments);				// Arguments(2) [1990, 1995, callee: ƒ, Symbol(Symbol.iterator): ƒ]
}
findAge(1990, 1995);

// ES6
function findAge(...years) {					// REST para
    console.log(years);							// [1990, 1995]
}
findAge(1990, 1995);

eg:
//ES5
function isFullAge5() {
    var argsArr = Array.prototype.slice.call(arguments);
    argsArr.forEach(function(cur) {
        console.log((2016 - cur) >= 18);
    })
}
isFullAge5(1990, 1999, 1965);
isFullAge5(1990, 1999, 1965, 2016, 1987);

//ES6
function isFullAge6(...years) {
    years.forEach(cur => console.log( (2016 - cur) >= 18));
}

isFullAge6(1990, 1999, 1965, 2016, 1987);


//ES5
function isFullAge5(limit) {
    var argsArr = Array.prototype.slice.call(arguments, 1);         // slice will cut from index 1 now
    argsArr.forEach(function(cur) {
        console.log((2016 - cur) >= limit);
    })
}
isFullAge5(16, 1990, 1999, 1965);

//ES6
function isFullAge6(limit, ...years) {
    years.forEach(cur => console.log( (2016 - cur) >= limit));
}
isFullAge6(16, 1990, 1999, 1965, 2016, 1987);


11. Default parameters

// ES5
function SmithPerson(firstName, yearOfBirth, lastName, nationality) {
    lastName === undefined ? lastName = 'Smith' : lastName = lastName;
    nationality === undefined ? nationality = 'american' : nationality = nationality;
    this.firstName = firstName;
    this.lastName = lastName;
    this.yearOfBirth = yearOfBirth;
    this.nationality = nationality;
}


//ES6
function SmithPerson(firstName, yearOfBirth, lastName = 'Smith', nationality = 'american') {
    this.firstName = firstName;
    this.lastName = lastName;
    this.yearOfBirth = yearOfBirth;
    this.nationality = nationality;
}
var john = new SmithPerson('John', 1990);
var emily = new SmithPerson('Emily', 1983, 'Diaz', 'spanish');


12. Map:
Its better than obj as we can create key as not onlt string, but other datatype as well

const question = new Map();
question.set('question', 'What is the official name of the latest major JavaScript version?');
question.set(1, 'ES5');
question.set(2, 'ES6');
question.set(3, 'ES2015');
question.set(4, 'ES7');
question.set('correct', 3);
question.set(true, 'Correct answer :D');
question.set(false, 'Wrong, please try again!');

console.log(question.get('question'));				// What is the official name of the latest major JavaScript version?
console.log(question.size);							// 8


if(question.has(4)) {
    question.delete(4);
    //console.log('Answer 4 is here')
}

//question.clear();


//question.forEach((value, key) => console.log(`This is ${key}, and it's set to ${value}`));


for (let [key, value] of question.entries()) {
    if (typeof(key) === 'number') {
        console.log(`Answer ${key}: ${value}`);						// Answer 1: ES5
																	   Answer 2: ES6  ...
    }
}

const ans = parseInt(prompt('Write the correct answer'));
console.log(question.get(ans === question.get('correct')));


13. Class
classes dont add anything new to the lang, they are just the easier way of doing prototype inheritance 
In ES5, the bluepints are called func constructors and we add func to their prototype property

//ES5
var Person5 = function(name, yearOfBirth, job) {
    this.name = name;
    this.yearOfBirth = yearOfBirth;
    this.job = job;
}

Person5.prototype.calculateAge = function() {
    var age = new Date().getFullYear - this.yearOfBirth;
    console.log(age);
}

var john5 = new Person5('John', 1990, 'teacher');

//ES6
class Person6 {
    constructor (name, yearOfBirth, job) {
        this.name = name;
        this.yearOfBirth = yearOfBirth;
        this.job = job;
    }
    
    calculateAge() {
        var age = new Date().getFullYear - this.yearOfBirth;
        console.log(age);
    }
    
    static greeting() {
        console.log('Hey there!');
    }
}

const john6 = new Person6('John', 1990, 'teacher');
Person6.greeting();										// static func directly called by class name

14. Classes and subclasses

//ES5
var Person5 = function(name, yearOfBirth, job) {
    this.name = name;
    this.yearOfBirth = yearOfBirth;
    this.job = job;
}

Person5.prototype.calculateAge = function() {
    var age = new Date().getFullYear() - this.yearOfBirth;
    console.log(age);
}

var Athlete5 = function(name, yearOfBirth, job, olymicGames, medals) {
    Person5.call(this, name, yearOfBirth, job);
    this.olymicGames = olymicGames;
    this.medals = medals;
}

Athlete5.prototype = Object.create(Person5.prototype);				// Object.create() help us to manually set the prototype of an object

Athlete5.prototype.wonMedal = function() {
    this.medals++;
    console.log(this.medals);
}

var johnAthlete5 = new Athlete5('John', 1990, 'swimmer', 3, 10);

johnAthlete5.calculateAge();
johnAthlete5.wonMedal();


//ES6
class Person6 {
    constructor (name, yearOfBirth, job) {
        this.name = name;
        this.yearOfBirth = yearOfBirth;
        this.job = job;
    }

    calculateAge() {
        var age = new Date().getFullYear() - this.yearOfBirth;
        console.log(age);
    }
}

class Athlete6 extends Person6 {
    constructor(name, yearOfBirth, job, olympicGames, medals) {
        super(name, yearOfBirth, job);
        this.olympicGames = olympicGames;
        this.medals = medals;
    }
    
    wonMedal() {
        this.medals++;
        console.log(this.medals);
    }
}

const johnAthlete6 = new Athlete6('John', 1990, 'swimmer', 3, 10);

johnAthlete6.wonMedal();
johnAthlete6.calculateAge();

___________________________________________________________________________________________________


15. Asynchronus JS: The code which running in the bg while the main code is still executing
eg: requesting some data from the remote server like an API

	<script>
        var first = () => {
            console.log('first call')
            second()
            console.log('The end')
        }
        
        var second = () => {
            console.log('second call')
        }
        
        first()
    </script>
O/P:
first call
second call
The end

BUT its  possible second func respond after 2 sec:
	var second = () => {
            setTimeout(() => {
                console.log('second call')
            }, 2 * 1000);
        }
O/P:
first call
The end
second call  (after 2 secs)

 16. promise:
 then() and catch() are availiabe on promise object
 then() handles the response of resolve while
 catch() handles the resp of reject

 Callback hell:
 		function getRecipe() {
             setTimeout(() => {
                 const recipeID = [523, 883, 432, 974];
                 console.log(recipeID);

                 setTimeout(id => {
                     const recipe = {title: 'Fresh tomato pasta', publisher: 'Jonas'};
                     console.log(`${id}: ${recipe.title}`);

                     setTimeout(publisher => {
                         const recipe2 = {title: 'Italian Pizza', publisher: 'Jonas'};
                         console.log(recipe);
                     }, 1500, recipe.publisher);

                 }, 1500, recipeID[2]);

             }, 1500);
         }
         getRecipe();
O/P: 
[523, 883, 432, 974]
432: Fresh tomato pasta
23 {title: "Fresh tomato pasta", publisher: "Jonas"}

NOW callback hell can be resolved by Promise, longer code though:
		const getIDs = new Promise((resolve, reject) => {            // Executor Fumction
             setTimeout(() => {
                 resolve([523, 883, 432, 974]);
             }, 1500);
         });

         const getRecipe = recID => {
             return new Promise((resolve, reject) => {
                 setTimeout(ID => {
                     const recipe = {title: 'Fresh tomato pasta', publisher: 'Jonas'};
                     resolve(`${ID}: ${recipe.title}`);
                 }, 1500, recID);
             });
         };

         const getRelated = publisher => {
             return new Promise((resolve, reject) => {
                 setTimeout(pub => {
                     const recipe = {title: 'Italian Pizza', publisher: 'Jonas'};
                     resolve(`${pub}: ${recipe.title}`);
                 }, 1500, publisher);
             });
         };

         getIDs
         .then(IDs => {                       // then func is availiable on all promise objects
             console.log(IDs);
             return getRecipe(IDs[2]);
         })
         .then(recipe => {
             console.log(recipe);
             return getRelated('Jonas Schmedtmann');
         })
         .then(recipe => {
             console.log(recipe);
         })
         .catch(error => {
             console.log('Error!!');
         });


17. async-await:
await always used inside an aync function
async func runs in the bg
eg:
  		async function getRecipesAW() {
             const IDs = await getIDs;        // await waits until this promise resolve
             console.log(IDs);
             const recipe = await getRecipe(IDs[2]);
             console.log(recipe);
             const related = await getRelated('Jonas Schmedtmann');
             console.log(related);
         }
         getRecipesAW()

async func always returns a promise, so we just cant get in inside a var but using then()
             return recipe;
         }
         getRecipesAW().then(result => console.log(`${result} is the best ever!`));


18. Making AJAX call with Fetch and promises:
    	function getWeather(woeid) {
            fetch(`https://cors-anywhere.herokuapp.com/https://www.metaweather.com/api/location/${woeid}/`)
            .then(result => {
                // console.log(result);
                return result.json();
            })
            .then(data => {
                // console.log(data);
                const today = data.consolidated_weather[0];
                console.log(`Temperatures today in ${data.title} stay between ${today.min_temp} and ${today.max_temp}.`);
            })
            .catch(error => console.log(error));
        }
        getWeather(2487956);
O/P: Temperatures today in San Francisco stay between 9.365 and 12.765.

CORS policy can be avoided by adding: https://cors-anywhere.herokuapp.com/
https://www.metaweather.com/api/location/ : A third party API to get weather info.


19. Doing the same using aync-await:
 		async function getWeatherAW(woeid) {
            try {
                const result = await fetch(`https://cors-anywhere.herokuapp.com/https://www.metaweather.com/api/location/${woeid}/`);
                const data = await result.json();
                const today = data.consolidated_weather[0];
                console.log(`Temperatures tomorrow in ${data.title} stay between ${today.min_temp} and ${today.max_temp}.`);
            } catch(error) {
                alert(error);
            }
        }
        getWeatherAW(2487956);
O/P: Temperatures today in San Francisco stay between 9.365 and 12.765.

Note: also we can return data and use it by then()

20. 
map() returns an array with the same length,
filter() as the name implies, it returns an array with less items than the original array
reduce() returns a single value (or object)
find() returns the first items in an array that satisfies a condition

21. Custom Validators with 2 controls:
function EndDateValidator(controlName: string, matchingControlName: string) {
  return (formGroup: FormGroup) => {
    const control = formGroup.controls[controlName];
    const matchingControl = formGroup.controls[matchingControlName];

    if (matchingControl.errors && !matchingControl.errors.isStartDateGreater) {
      return;
    }

    if (matchingControl.value) {
      if (
        new Date(control.value.toLocaleDateString()) >
        new Date(matchingControl.value.toLocaleDateString())
      ) {
        matchingControl.setErrors({ isStartDateGreater: true });
      } else {
        matchingControl.setErrors(null);
      }
    }
  };
}
